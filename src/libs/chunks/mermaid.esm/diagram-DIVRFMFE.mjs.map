{
  "version": 3,
  "sources": ["../../../src/diagrams/visual/db.ts", "../../../src/diagrams/visual/parser.ts", "../../../src/diagrams/visual/getColor.ts", "../../../src/diagrams/visual/valueFormatter.ts", "../../../src/diagrams/visual/drawArrayDiagram.ts", "../../../src/diagrams/visual/drawMatrixDiagram.ts", "../../../src/diagrams/visual/drawStackDiagram.ts", "../../../src/diagrams/visual/drawGraphDiagram.ts", "../../../src/diagrams/visual/drawTreeDiagram.ts", "../../../src/diagrams/visual/drawLinkedListDiagram.ts", "../../../src/diagrams/visual/drawTextDiagram.ts", "../../../src/diagrams/visual/renderer.ts", "../../../src/diagrams/visual/styles.ts", "../../../src/diagrams/visual/diagram.ts"],
  "sourcesContent": ["import { getConfig as commonGetConfig } from '../../config.js';\nimport type { VisualDiagramConfig } from '../../config.type.js';\nimport DEFAULT_CONFIG from '../../defaultConfig.js';\nimport { cleanAndMerge } from '../../utils.js';\nimport {\n  clear as commonClear,\n  getAccDescription,\n  getAccTitle,\n  getDiagramTitle,\n  setAccDescription,\n  setAccTitle,\n  setDiagramTitle,\n} from '../common/commonDb.js';\nimport type { VisualDB, VisualPage, SizeDefinition } from './types.js';\n\nconst defaultVisualData: VisualPage[] = [];\n\nlet data: VisualPage[] = [...defaultVisualData];\nlet diagramSize: SizeDefinition | undefined;\n\nconst DEFAULT_VISUAL_CONFIG: Required<VisualDiagramConfig> = DEFAULT_CONFIG.visual;\n\nconst getConfig = (): Required<VisualDiagramConfig> => {\n  return cleanAndMerge({\n    ...DEFAULT_VISUAL_CONFIG,\n    ...commonGetConfig().visual,\n  });\n};\n\nconst getPages = (): VisualPage[] => data;\n\nconst addPage = (page: VisualPage) => {\n  data.push(page);\n};\n\nconst getSize = (): SizeDefinition | undefined => diagramSize;\n\nconst setSize = (size: SizeDefinition) => {\n  diagramSize = size;\n};\n\nconst clear = () => {\n  commonClear();\n  data = [...defaultVisualData];\n  diagramSize = undefined;\n};\n\nexport const db: VisualDB = {\n  getPages,\n  addPage,\n  getConfig,\n  clear,\n  setAccTitle,\n  getAccTitle,\n  setDiagramTitle,\n  getDiagramTitle,\n  getAccDescription,\n  setAccDescription,\n  getSize,\n  setSize,\n};\n", "import type { VisualDiagram } from '@mermaid-js/parser';\nimport { parse } from '@mermaid-js/parser';\nimport type { ParserDefinition } from '../../diagram-api/types.js';\nimport { log } from '../../logger.js';\nimport { populateCommonDb } from '../common/populateCommonDb.js';\nimport { db } from './db.js';\n\nconst populate = (ast: VisualDiagram) => {\n  populateCommonDb(ast, db);\n\n  // Handle optional size parameter\n  if (ast.size && db.setSize) {\n    db.setSize({\n      width: ast.size.width,\n      height: ast.size.height,\n    });\n  }\n\n  // Helper function to process position data\n  const processPosition = (position: any, placement?: string) => {\n    if (!position) {\n      return undefined;\n    }\n\n    // Check if it has column and row (absolute position)\n    if ('column' in position && 'row' in position) {\n      return {\n        column: position.column,\n        row: position.row,\n      };\n    }\n\n    // Otherwise it's a relative position ('previous')\n    return {\n      type: 'previous' as const,\n      placement: (placement || 'below') as 'left' | 'right' | 'above' | 'below',\n    };\n  };\n\n  for (const page of ast.pages) {\n    const subDiagrams = page.subDiagrams.map((subDiagram) => {\n      switch (subDiagram.diagramType) {\n        case 'array':\n          return {\n            type: 'array',\n            orientation: subDiagram.orientation,\n            title: subDiagram.diagramTitle,\n            position: processPosition(subDiagram.position),\n            showIndex: subDiagram.showIndex,\n            label: subDiagram.label,\n            elements: subDiagram.elements.map((e: any) => ({\n              value: e.value,\n              color: e.color,\n              arrow: e.arrowLabel !== undefined && e.arrowLabel !== null, //if with arrow then True, else False\n              arrowLabel: e.arrowLabel,\n            })),\n          };\n        case 'matrix':\n          return {\n            type: 'matrix',\n            title: subDiagram.diagramTitle,\n            position: processPosition(subDiagram.position),\n            rows: subDiagram.rows.map((row: any) => ({\n              elements: row.elements.map((e: any) => ({\n                value: e.value,\n                color: e.color,\n                arrow: e.arrowLabel !== undefined && e.arrowLabel !== null, //if with arrow then True, else False\n                arrowLabel: e.arrowLabel,\n              })),\n            })),\n            showIndex: subDiagram.showIndex,\n            label: subDiagram.label,\n          };\n        case 'stack':\n          return {\n            type: 'stack',\n            orientation: subDiagram.orientation,\n            title: subDiagram.diagramTitle,\n            position: processPosition(subDiagram.position),\n            showIndex: subDiagram.showIndex,\n            label: subDiagram.label,\n            size: subDiagram.size,\n            elements: subDiagram.elements.map((e: any) => ({\n              value: e.value,\n              color: e.color,\n              arrow: e.arrowLabel !== undefined && e.arrowLabel !== null, //if with arrow then True, else False\n              arrowLabel: e.arrowLabel,\n            })),\n          };\n        case 'tree':\n          return {\n            type: 'tree',\n            title: subDiagram.diagramTitle,\n            position: processPosition(subDiagram.position),\n            label: subDiagram.label,\n            elements: subDiagram.elements.map((element: any) => ({\n              nodeId: element.nodeId,\n              left: element.left == 'None' ? undefined : element.left,\n              right: element.right == 'None' ? undefined : element.right,\n              value: element.value,\n              color: element.color,\n              arrow: element.arrowLabel !== undefined && element.arrowLabel !== null, //if with arrow then True, else False\n              arrowLabel: element.arrowLabel,\n            })),\n          };\n        case 'graph':\n          return {\n            type: 'graph',\n            title: subDiagram.diagramTitle,\n            position: processPosition(subDiagram.position),\n            label: subDiagram.label,\n            elements: subDiagram.elements.map((element: any) => {\n              if (element.$type == 'NodeDefinition') {\n                return {\n                  type: 'node',\n                  nodeId: element.nodeId,\n                  value: element.value,\n                  color: element.color,\n                  arrow: element.arrowLabel !== undefined && element.arrowLabel !== null,\n                  arrowLabel: element.arrowLabel,\n                  hidden: (element.hidden || '').toLowerCase() == 'true',\n                };\n              } else if (element.$type == 'EdgeDefinition') {\n                return {\n                  type: 'edge',\n                  start: element.start,\n                  end: element.end,\n                  value: element.value,\n                  color: element.color,\n                };\n              } else {\n                throw new Error('Unknown graph element type');\n              }\n            }),\n          };\n        case 'linkedList':\n          return {\n            type: 'linkedList',\n            title: subDiagram.diagramTitle,\n            position: processPosition(subDiagram.position),\n            label: subDiagram.label,\n            elements: subDiagram.elements.map((e: any) => ({\n              value: e.value,\n              color: e.color,\n              arrow: e.arrowLabel ? true : false,\n              arrowLabel: e.arrowLabel,\n            })),\n          };\n        case 'text':\n          return {\n            type: 'text',\n            title: subDiagram.diagramTitle,\n            position: processPosition(subDiagram.position, subDiagram.placement),\n            fontSize: subDiagram.fontSize,\n            color: subDiagram.color,\n            fontWeight: subDiagram.fontWeight,\n            fontFamily: subDiagram.fontFamily,\n            align: subDiagram.align,\n            lineSpacing: subDiagram.lineSpacing,\n            width: subDiagram.width,\n            height: subDiagram.height,\n            label: subDiagram.label,\n            elements: subDiagram.elements.map((e: any) => {\n              if (e.attributes && e.attributes.length > 0) {\n                // Build element properties from attributes array\n                const elementProps: any = { value: e.value };\n                e.attributes.forEach((attr: any) => {\n                  elementProps[attr.name] = attr.value;\n                });\n                return elementProps;\n              } else {\n                return e.value;\n              }\n            }),\n          };\n        default:\n          throw new Error(`Unknown diagram type: ${subDiagram.diagramType}`);\n      }\n    });\n\n    db.addPage({\n      layout: page.layout\n        ? {\n            columns: page.layout.columns,\n            rows: page.layout.rows,\n          }\n        : undefined,\n      subDiagrams,\n    });\n  }\n};\n\nexport const parser: ParserDefinition = {\n  parse: async (input: string): Promise<void> => {\n    const ast: VisualDiagram = await parse('visual', input);\n    log.debug(ast);\n    populate(ast);\n  },\n};\n", "export const getColor = (color?: string, transparency: number = 0.6): string => {\n  if (isValidHexColor(color)) {\n    return color || 'null';\n  }\n\n  const colorMap: Record<string, string> = {\n    black: '#000000',\n    white: '#FFFFFF',\n    red: '#FF0000',\n    green: '#008000',\n    blue: '#0000FF',\n    yellow: '#FFFF00',\n    cyan: '#00FFFF',\n    magenta: '#FF00FF',\n    gray: '#808080',\n    grey: '#808080', // Allow British spelling\n    maroon: '#800000',\n    olive: '#808000',\n    purple: '#800080',\n    teal: '#008080',\n    navy: '#000080',\n    orange: '#FFA500',\n    pink: '#FFC0CB',\n    brown: '#A52A2A',\n    aqua: '#00FFFF',\n    lime: '#00FF00',\n    gold: '#FFD700',\n    silver: '#C0C0C0',\n    beige: '#F5F5DC',\n    coral: '#FF7F50',\n    chocolate: '#D2691E',\n    crimson: '#DC143C',\n    indigo: '#4B0082',\n    khaki: '#F0E68C',\n    lavender: '#E6E6FA',\n    orchid: '#DA70D6',\n    plum: '#DDA0DD',\n    salmon: '#FA8072',\n    sienna: '#A0522D',\n    turquoise: '#40E0D0',\n    violet: '#EE82EE',\n    wheat: '#F5DEB3',\n    azure: '#F0FFFF',\n    ivory: '#FFFFF0',\n    mintcream: '#F5FFFA',\n    snow: '#FFFAFA',\n    goldenrod: '#DAA520',\n    tomato: '#FF6347',\n    slateblue: '#6A5ACD',\n    darkgreen: '#006400',\n    darkblue: '#00008B',\n    darkred: '#8B0000',\n    darkorange: '#FF8C00',\n    darkviolet: '#9400D3',\n    darkkhaki: '#BDB76B',\n    lightblue: '#ADD8E6',\n    lightgreen: '#90EE90',\n    lightcoral: '#F08080',\n    lightgray: '#D3D3D3',\n    lightgrey: '#D3D3D3', // British spelling\n  };\n\n  const lowerColor = color ? color.toLowerCase() : '';\n\n  if (lowerColor in colorMap) {\n    const hexColor = colorMap[lowerColor as keyof typeof colorMap];\n    const rgbaColor = hexToRgba(hexColor, transparency);\n    return rgbaColor;\n  } else {\n    return 'white';\n  }\n};\n\nfunction isValidHexColor(color?: string): boolean {\n  if (!color) {\n    return false;\n  }\n  // Regular expression for matching 3 or 6 digit hex color codes\n  const hexColorRegex = /^#([\\dA-Fa-f]{3}){1,2}$/;\n\n  // Test the color against the regex\n  return hexColorRegex.test(color);\n}\n\n// Helper function to convert hex to RGBA\nconst hexToRgba = (hex: string, alpha: number): string => {\n  hex = hex.replace(/^#/, '');\n\n  const r = parseInt(hex.slice(0, 2), 16);\n  const g = parseInt(hex.slice(2, 4), 16);\n  const b = parseInt(hex.slice(4, 6), 16);\n\n  return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n};\n", "/**\n * Formats a value for display in visual diagrams.\n * Handles special cases for null values and quoted strings.\n *\n * @param value - The raw value from the parsed diagram\n * @returns The formatted value for display\n */\nexport const formatValue = (value: string | number): string => {\n  let rawValue = value.toString();\n\n  // Remove quotes if it's a string literal\n  if (rawValue.startsWith('\"') && rawValue.endsWith('\"')) {\n    rawValue = rawValue.slice(1, -1);\n  }\n\n  // Handle special null cases:\n  // - 'null' (literal) should display as empty string\n  // - '\\null' (escaped null) should display as \"null\"\n  if (rawValue === 'null') {\n    return '';\n  }\n  if (rawValue === '\\\\null') {\n    return 'null';\n  }\n\n  return rawValue;\n};\n\n/**\n * Checks if an arrow label should be displayed.\n *\n * @param arrowLabel - The arrow label value\n * @returns True if the arrow label should be displayed, false otherwise\n */\nexport const shouldDisplayArrowLabel = (arrowLabel?: string): boolean => {\n  if (!arrowLabel) {\n    return false;\n  }\n\n  let rawValue = arrowLabel.toString();\n\n  // Remove quotes if it's a string literal\n  if (rawValue.startsWith('\"') && rawValue.endsWith('\"')) {\n    rawValue = rawValue.slice(1, -1);\n  }\n\n  return rawValue !== 'null';\n};\n", "import type { ArrayDiagram, ArrayElement } from './types.js';\nimport type { ArrayDiagramConfig } from '../../config.type.js';\nimport type { SVG } from '../../diagram-api/types.js';\nimport { getColor } from './getColor.js';\nimport { formatValue, shouldDisplayArrowLabel } from './valueFormatter.js';\n\nexport const drawArrayDiagram = (\n  svg: SVG,\n  arrayDiagram: ArrayDiagram,\n  config: Required<ArrayDiagramConfig>,\n  component_id: number\n) => {\n  // Add marker definition for the arrowhead\n  svg\n    .append('defs')\n    .append('marker')\n    .attr('id', 'arrowhead')\n    .attr('viewBox', '0 0 10 10')\n    .attr('refX', '5')\n    .attr('refY', '5')\n    .attr('markerWidth', '6')\n    .attr('markerHeight', '6')\n    .attr('orient', 'auto-start-reverse')\n    .append('path')\n    .attr('d', 'M 0 0 L 10 5 L 0 10 z')\n    .attr('fill', 'black');\n\n  // title style parameters\n  const titleFontSize = '16';\n  const title_X = 100;\n  const title_Y = 20;\n\n  // label style parameters\n  const labelFontSize = '16';\n  const label_X = 100;\n  const label_Y = 160;\n\n  // Add the title to the top center of the SVG\n  if (arrayDiagram.title) {\n    svg\n      .append('text')\n      .attr('x', title_X)\n      .attr('y', title_Y)\n      .attr('fill', config.labelColor)\n      .attr('font-size', titleFontSize)\n      .attr('dominant-baseline', 'hanging')\n      .attr('text-anchor', 'middle')\n      .attr('class', 'arrayDiagramTitle')\n      .text(arrayDiagram.title);\n  }\n\n  // Apply right shift by adjusting the x translation value\n  const xOffset = 50;\n  const group = svg\n    .append('g')\n    .attr('class', 'component')\n    .attr('id', `component_${component_id}`)\n    .attr('transform', `translate(${xOffset}, 40)`);\n\n  let unit_id = 0;\n\n  arrayDiagram.elements.forEach((element, index) => {\n    drawElement(\n      group as unknown as SVG,\n      element,\n      index,\n      config,\n      arrayDiagram.showIndex || false,\n      unit_id\n    );\n    unit_id += 1;\n  });\n\n  if (arrayDiagram.label) {\n    const labelYPosition = label_Y;\n    const labelXPosition = label_X;\n\n    group\n      .append('text')\n      .attr('x', labelXPosition)\n      .attr('y', labelYPosition)\n      .attr('fill', config.labelColor)\n      .attr('font-size', labelFontSize)\n      .attr('dominant-baseline', 'hanging')\n      .attr('text-anchor', 'middle')\n      .attr('class', 'arrayDiagramLabel')\n      .text(arrayDiagram.label);\n  }\n};\n\nconst drawElement = (\n  svg: SVG,\n  element: ArrayElement,\n  index: number,\n  { labelColor, labelFontSize }: Required<ArrayDiagramConfig>,\n  showIndex: boolean,\n  unit_id: number\n) => {\n  // array element style parameters\n  const indexFontSize = '16';\n  const elementFontSize = '16';\n\n  const group = svg.append('g');\n  group.attr('class', 'unit').attr('id', `unit_${unit_id}`);\n  const elementSize = 40;\n  const elementX = index * elementSize;\n  const elementY = 50;\n\n  const fillColor = getColor(element.color);\n\n  if (element.arrow && shouldDisplayArrowLabel(element.arrowLabel)) {\n    const arrowYStart = elementY - 40;\n    const arrowYEnd = elementY - 10;\n    group\n      .append('line')\n      .attr('x1', elementX + 20)\n      .attr('y1', arrowYStart)\n      .attr('x2', elementX + 20)\n      .attr('y2', arrowYEnd)\n      .attr('stroke', 'black')\n      .attr('stroke-width', '1.5')\n      .attr('marker-end', 'url(#arrowhead)');\n\n    if (shouldDisplayArrowLabel(element.arrowLabel)) {\n      group\n        .append('text')\n        .attr('x', elementX + 20)\n        .attr('y', arrowYStart - 20)\n        .attr('fill', labelColor)\n        .attr('font-size', '16')\n        .attr('dominant-baseline', 'hanging')\n        .attr('text-anchor', 'middle')\n        .attr('class', 'arrowContext')\n        .text(formatValue(element.arrowLabel || ''));\n    }\n  }\n\n  group\n    .append('rect')\n    .attr('x', elementX)\n    .attr('y', elementY)\n    .attr('width', elementSize)\n    .attr('height', elementSize)\n    .style('fill', fillColor)\n    .attr('stroke', '#000000')\n    .attr('stroke-width', '2px')\n    .attr('class', 'arrayElement');\n\n  group\n    .append('text')\n    .attr('x', elementX + elementSize / 2)\n    .attr('y', elementY + elementSize / 2)\n    .attr('fill', labelColor)\n    .attr('font-size', elementFontSize)\n    .attr('dominant-baseline', 'middle')\n    .attr('text-anchor', 'middle')\n    .attr('class', 'elementLabel')\n    .text(formatValue(element.value));\n\n  if (showIndex) {\n    group\n      .append('text')\n      .attr('x', elementX + elementSize / 2)\n      .attr('y', elementY + elementSize + 20)\n      .attr('fill', labelColor)\n      .attr('font-size', indexFontSize)\n      .attr('dominant-baseline', 'middle')\n      .attr('text-anchor', 'middle')\n      .attr('class', 'indexLabel')\n      .text(index);\n  }\n};\n", "import type { MatrixDiagram, MatrixElement } from './types.js';\nimport type { MatrixDiagramConfig } from '../../config.type.js';\nimport type { SVG } from '../../diagram-api/types.js';\nimport { getColor } from './getColor.js';\nimport { formatValue, shouldDisplayArrowLabel } from './valueFormatter.js';\n\nexport const drawMatrixDiagram = (\n  svg: SVG,\n  matrixDiagram: MatrixDiagram,\n  config: Required<MatrixDiagramConfig>,\n  component_id: number\n) => {\n  const xOffset = 50; // Adjust this value to shift the matrix to the right\n  const titleOffset = matrixDiagram.title ? 100 : 0; // Space for the title if it exists\n  const group = svg.append('g');\n  group.attr('class', 'component').attr('id', `component_${component_id}`);\n\n  const rowCount = matrixDiagram.rows.length;\n  const colCount = Math.max(...matrixDiagram.rows.map((row) => row.elements.length));\n\n  // Add title if it exists\n  if (matrixDiagram.title) {\n    svg\n      .append('text')\n      .attr('x', xOffset)\n      .attr('y', 0)\n      .attr('fill', config.labelColor)\n      .attr('font-size', config.labelFontSize)\n      .attr('dominant-baseline', 'hanging')\n      .attr('text-anchor', 'start')\n      .attr('class', 'diagramTitle')\n      .text(matrixDiagram.title);\n  }\n\n  matrixDiagram.rows.forEach((row, rowIndex) => {\n    row.elements.forEach((element, colIndex) => {\n      drawElement(group as unknown as SVG, element, rowIndex, colIndex, config);\n      drawGrid(group as unknown as SVG, rowIndex, colIndex, config); // Draw grid only for existing elements\n    });\n  });\n\n  if (matrixDiagram.label) {\n    const labelYPosition = rowCount * 50 + 50; // Increase the gap between the matrix and the label\n    const labelXPosition = colCount * 25; // Centered under the matrix\n\n    group\n      .append('text')\n      .attr('x', labelXPosition)\n      .attr('y', labelYPosition)\n      .attr('fill', config.labelColor)\n      .attr('font-size', config.labelFontSize)\n      .attr('dominant-baseline', 'hanging')\n      .attr('text-anchor', 'middle')\n      .attr('class', 'arrayDiagramLabel')\n      .text(matrixDiagram.label);\n  }\n\n  if (matrixDiagram.showIndex) {\n    addIndices(group as unknown as SVG, rowCount, colCount, config);\n  }\n};\n\nconst drawElement = (\n  svg: SVG,\n  element: MatrixElement,\n  rowIndex: number,\n  colIndex: number,\n  { labelColor, labelFontSize }: Required<MatrixDiagramConfig>\n) => {\n  const group = svg.append('g');\n  group.attr('class', 'unit').attr('id', `unit_(${rowIndex},${colIndex})`);\n\n  const elementX = colIndex * 50;\n  const elementY = rowIndex * 50;\n\n  const borderColor = '#000000';\n  const borderWidth = '1.2px';\n\n  const fillColor = getColor(element.color);\n\n  // Draw the rectangle for the matrix element\n  group\n    .append('rect')\n    .attr('x', elementX)\n    .attr('y', elementY)\n    .attr('width', 50)\n    .attr('height', 50)\n    .style('fill', fillColor)\n    .attr('stroke', borderColor)\n    .attr('stroke-width', borderWidth)\n    .attr('class', 'matrixElement');\n\n  // Format the element value using the utility function\n  const formattedValue = formatValue(element.value);\n\n  // Draw the text inside the matrix element\n  group\n    .append('text')\n    .attr('x', elementX + 25)\n    .attr('y', elementY + 25)\n    .attr('fill', labelColor)\n    .attr('font-size', labelFontSize)\n    .attr('dominant-baseline', 'middle')\n    .attr('text-anchor', 'middle')\n    .attr('class', 'elementLabel')\n    .text(formattedValue);\n\n  // Draw the red circle and arrow label if the arrow exists\n  if (element.arrow && shouldDisplayArrowLabel(element.arrowLabel)) {\n    // Draw the red circle around the element\n    group\n      .append('circle')\n      .attr('cx', elementX + 25)\n      .attr('cy', elementY + 25)\n      .attr('r', 23)\n      .attr('stroke', 'red')\n      .attr('stroke-width', '2')\n      .attr('fill', 'none');\n\n    // Draw the arrow label near the circle\n    group\n      .append('text')\n      .attr('x', elementX + 52) // Position to the right of the circle\n      .attr('y', elementY + 25)\n      .attr('fill', 'red')\n      .attr('font-size', labelFontSize)\n      .attr('dominant-baseline', 'middle')\n      .attr('text-anchor', 'start')\n      .attr('class', 'arrowLabel')\n      .text(formatValue(element.arrowLabel || ''));\n  }\n};\n\nconst addIndices = (\n  svg: SVG,\n  rowCount: number,\n  colCount: number,\n  { labelColor, labelFontSize }: Required<MatrixDiagramConfig>\n) => {\n  const indexGroup = svg.append('g');\n\n  // Draw row indices\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    indexGroup\n      .append('text')\n      .attr('x', -10)\n      .attr('y', rowIndex * 50 + 25)\n      .attr('fill', labelColor)\n      .attr('font-size', labelFontSize)\n      .attr('dominant-baseline', 'middle')\n      .attr('text-anchor', 'middle')\n      .attr('class', 'rowIndex')\n      .text(rowIndex.toString());\n  }\n\n  // Draw column indices\n  for (let colIndex = 0; colIndex < colCount; colIndex++) {\n    indexGroup\n      .append('text')\n      .attr('x', colIndex * 50 + 25)\n      .attr('y', -10)\n      .attr('fill', labelColor)\n      .attr('font-size', labelFontSize)\n      .attr('dominant-baseline', 'middle')\n      .attr('text-anchor', 'middle')\n      .attr('class', 'colIndex')\n      .text(colIndex.toString());\n  }\n};\n\nconst drawGrid = (\n  svg: SVG,\n  rowIndex: number,\n  colIndex: number,\n  { borderColor, borderWidth }: Required<MatrixDiagramConfig>\n) => {\n  const gridGroup = svg.append('g');\n  const x = colIndex * 50;\n  const y = rowIndex * 50;\n\n  gridGroup\n    .append('rect')\n    .attr('x', x)\n    .attr('y', y)\n    .attr('width', 50)\n    .attr('height', 50)\n    .attr('stroke', borderColor)\n    .attr('stroke-width', borderWidth)\n    .attr('fill', 'none');\n};\n", "import type { StackDiagram, StackElement } from './types.js';\nimport type { SVG } from '../../diagram-api/types.js';\nimport { getColor } from './getColor.js';\nimport { formatValue, shouldDisplayArrowLabel } from './valueFormatter.js';\n\nexport const drawStackDiagram = (svg: SVG, stackDiagram: StackDiagram, component_id: number) => {\n  // Add marker definition for the arrowhead\n  svg\n    .append('defs')\n    .append('marker')\n    .attr('id', 'arrowhead')\n    .attr('viewBox', '0 0 10 10')\n    .attr('refX', '5')\n    .attr('refY', '5')\n    .attr('markerWidth', '6')\n    .attr('markerHeight', '6')\n    .attr('orient', 'auto')\n    .append('path')\n    .attr('d', 'M 0 0 L 10 5 L 0 10 z')\n    .attr('fill', 'black');\n\n  const group = svg.append('g');\n  group.attr('class', 'component').attr('id', `component_${component_id}`);\n\n  // Draw the framework of the stack\n  const stackHeight = stackDiagram.size * 40;\n  drawFramework(group as unknown as SVG, 50, 0, 70, stackHeight);\n  let unit_id = 0;\n\n  // Draw each stack element, positioning them from the bottom of the stack upwards\n  stackDiagram.elements.forEach((element, index) => {\n    const positionIndex = stackDiagram.size - stackDiagram.elements.length + index;\n    drawElement(group as unknown as SVG, element, positionIndex, unit_id);\n    unit_id += 1;\n  });\n\n  if (stackDiagram.label) {\n    // Calculate the total height of the stack diagram\n    const totalHeight = stackHeight + 40; // Adjust this value based on the height of your elements and desired spacing\n    const labelYPosition = totalHeight + 20; // Adjust this value based on the height of your elements and desired spacing\n    const labelXPosition = 85; // Center the label horizontally based on element width\n\n    group\n      .append('text')\n      .attr('x', labelXPosition)\n      .attr('y', labelYPosition)\n      .attr('fill', 'black')\n      .attr('font-size', '16')\n      .attr('dominant-baseline', 'hanging')\n      .attr('text-anchor', 'middle')\n      .attr('class', 'stackDiagramLabel')\n      .text(stackDiagram.label);\n  }\n};\n\nconst drawElement = (svg: SVG, element: StackElement, positionIndex: number, unit_id: number) => {\n  const group = svg.append('g');\n  group.attr('class', 'unit').attr('id', `unit_${unit_id}`);\n  const elementX = 50;\n  const elementY = positionIndex * 40;\n\n  const fillColor = getColor(element.color);\n\n  group\n    .append('rect')\n    .attr('x', elementX)\n    .attr('y', elementY)\n    .attr('width', 70)\n    .attr('height', 40)\n    .style('fill', fillColor)\n    .attr('stroke', 'black')\n    .attr('stroke-width', '1')\n    .attr('class', 'stackElement');\n\n  if (element.arrow && shouldDisplayArrowLabel(element.arrowLabel)) {\n    const arrowXStart = elementX + 80; // Start at the right edge of the element\n    const arrowXEnd = arrowXStart + 40; // Extend the arrow further to the right\n\n    group\n      .append('line')\n      .attr('x1', arrowXEnd)\n      .attr('y1', elementY + 20)\n      .attr('x2', arrowXStart)\n      .attr('y2', elementY + 20)\n      .attr('stroke', 'black')\n      .attr('stroke-width', '1.5')\n      .attr('marker-end', 'url(#arrowhead)'); // Arrowhead points towards the element from the right\n\n    if (shouldDisplayArrowLabel(element.arrowLabel)) {\n      group\n        .append('text')\n        .attr('x', arrowXEnd + 10)\n        .attr('y', elementY + 20)\n        .attr('fill', 'black')\n        .attr('font-size', '16')\n        .attr('dominant-baseline', 'middle')\n        .attr('text-anchor', 'start')\n        .attr('class', 'arrowContext')\n        .text(formatValue(element.arrowLabel || ''));\n    }\n  }\n\n  group\n    .append('text')\n    .attr('x', elementX + 35)\n    .attr('y', elementY + 20)\n    .attr('fill', 'black')\n    .attr('font-size', '16')\n    .attr('dominant-baseline', 'middle')\n    .attr('text-anchor', 'middle')\n    .attr('class', 'elementLabel')\n    .text(formatValue(element.value));\n};\n\nconst drawFramework = (svg: SVG, x: number, y: number, width: number, height: number) => {\n  const borderColor = '#000000';\n  const borderWidth = 2;\n\n  // Draw left side\n  svg\n    .append('line')\n    .attr('x1', x)\n    .attr('y1', y)\n    .attr('x2', x)\n    .attr('y2', y + height)\n    .attr('stroke', borderColor)\n    .attr('stroke-width', borderWidth);\n\n  // Draw right side\n  svg\n    .append('line')\n    .attr('x1', x + width)\n    .attr('y1', y)\n    .attr('x2', x + width)\n    .attr('y2', y + height)\n    .attr('stroke', borderColor)\n    .attr('stroke-width', borderWidth);\n\n  // Draw bottom\n  svg\n    .append('line')\n    .attr('x1', x)\n    .attr('y1', y + height)\n    .attr('x2', x + width)\n    .attr('y2', y + height)\n    .attr('stroke', borderColor)\n    .attr('stroke-width', borderWidth);\n};\n", "import type { GraphDiagram, GraphNode, GraphEdge } from './types.js';\nimport type { SVG } from '../../diagram-api/types.js';\nimport { getColor } from './getColor.js';\nimport { formatValue, shouldDisplayArrowLabel } from './valueFormatter.js';\n\nexport const drawGraphDiagram = (svg: SVG, graphDiagram: GraphDiagram, component_id: number) => {\n  const group = svg.append('g');\n  group.attr('class', 'component').attr('id', `component_${component_id}`);\n\n  // Define the marker for the arrowhead\n  group\n    .append('defs')\n    .append('marker')\n    .attr('id', 'arrowhead')\n    .attr('viewBox', '0 0 10 10')\n    .attr('refX', '5')\n    .attr('refY', '5')\n    .attr('markerWidth', '4')\n    .attr('markerHeight', '5')\n    .attr('orient', 'auto')\n    .append('path')\n    .attr('d', 'M 0 0 L 10 5 L 0 10 z')\n    .attr('fill', 'black');\n\n  const graphNodes = graphDiagram.elements.filter((ele) => ele.type == 'node');\n  const hiddenNodeIds = new Set(\n    graphNodes.filter((node) => node.hidden).map((node) => node.nodeId)\n  );\n  const visibleGraphNodes = graphNodes.filter((node) => !node.hidden);\n\n  const graphEdges = graphDiagram.elements.filter(\n    (ele) => ele.type == 'edge' && !hiddenNodeIds.has(ele.start) && !hiddenNodeIds.has(ele.end)\n  );\n\n  // Calculate node positions in a circular layout (including hidden nodes)\n  const nodePositions = calculateNodePositions(graphNodes || []);\n\n  // Draw graph edges first (excluding those connected to hidden nodes)\n  if (graphEdges) {\n    graphEdges.forEach((edge) => {\n      drawEdge(group as unknown as SVG, edge, nodePositions);\n    });\n  }\n\n  // Draw graph nodes (excluding hidden nodes)\n  if (visibleGraphNodes) {\n    let unit_id = 0;\n    visibleGraphNodes.forEach((node) => {\n      drawNode(group as unknown as SVG, node, nodePositions[node.nodeId], unit_id);\n      unit_id += 1;\n    });\n  }\n\n  if (graphDiagram.label) {\n    // Add the label at the bottom\n    const labelYPosition = visibleGraphNodes\n      ? Math.ceil(visibleGraphNodes.length / 3) * 100 + 70\n      : 100;\n    const labelXPosition = 150; // Adjust based on your diagram size and layout\n\n    group\n      .append('text')\n      .attr('x', labelXPosition)\n      .attr('y', labelYPosition)\n      .attr('fill', 'black')\n      .attr('font-size', '16')\n      .attr('dominant-baseline', 'hanging')\n      .attr('text-anchor', 'middle')\n      .attr('class', 'graphDiagramLabel')\n      .text(graphDiagram.label);\n  }\n};\n\nconst calculateNodePositions = (\n  nodes: GraphNode[]\n): { [key: string]: { x: number; y: number } } => {\n  const positions: { [key: string]: { x: number; y: number } } = {};\n  const radius = 100; // Radius of the circle\n  const centerX = 150; // Center X position of the circle\n  const centerY = 150; // Center Y position of the circle\n  const angleIncrement = (2 * Math.PI) / nodes.length;\n\n  nodes.forEach((node, index) => {\n    const angle = index * angleIncrement;\n    positions[node.nodeId] = {\n      x: centerX + radius * Math.cos(angle),\n      y: centerY + radius * Math.sin(angle),\n    };\n  });\n\n  return positions;\n};\n\nconst drawNode = (\n  svg: SVG,\n  node: GraphNode,\n  position: { x: number; y: number },\n  unit_id: number\n) => {\n  // Skip drawing if the node is hidden\n  if (node.hidden) {\n    return;\n  }\n\n  const nodeX = position.x;\n  const nodeY = position.y;\n\n  const fillColor = getColor(node.color);\n  const group = svg.append('g');\n  group.attr('class', 'unit').attr('id', `unit_${unit_id}`);\n\n  group\n    .append('circle')\n    .attr('cx', nodeX)\n    .attr('cy', nodeY)\n    .attr('r', 20)\n    .style('fill', fillColor)\n    .attr('stroke', 'black')\n    .attr('stroke-width', '1')\n    .attr('class', 'graphNode');\n\n  group\n    .append('text')\n    .attr('x', nodeX)\n    .attr('y', nodeY)\n    .attr('dy', '.35em')\n    .attr('fill', 'black')\n    .attr('font-size', '16')\n    .attr('dominant-baseline', 'middle')\n    .attr('text-anchor', 'middle')\n    .attr('class', 'nodeLabel')\n    .text(formatValue(node.value || node.nodeId));\n\n  // Draw the arrow on the right side of the node, pointing towards the node\n  if (node.arrow && shouldDisplayArrowLabel(node.arrowLabel)) {\n    const arrowXStart = nodeX + 45; // Start slightly to the right of the node\n    const arrowXEnd = nodeX + 25; // End at the node edge\n\n    group\n      .append('line')\n      .attr('x1', arrowXStart)\n      .attr('y1', nodeY)\n      .attr('x2', arrowXEnd)\n      .attr('y2', nodeY)\n      .attr('stroke', 'black')\n      .attr('stroke-width', '2')\n      .attr('marker-end', 'url(#arrowhead)');\n\n    // Draw the arrow label if it exists\n    group\n      .append('text')\n      .attr('x', arrowXStart + 5)\n      .attr('y', nodeY)\n      .attr('fill', 'black')\n      .attr('font-size', '14')\n      .attr('dominant-baseline', 'middle')\n      .attr('text-anchor', 'start')\n      .attr('class', 'arrowLabel')\n      .text(formatValue(node.arrowLabel || ''));\n  }\n};\n\nconst drawEdge = (\n  svg: SVG,\n  edge: GraphEdge,\n  nodePositions: { [key: string]: { x: number; y: number } }\n) => {\n  const startNodePosition = nodePositions[edge.start];\n  const endNodePosition = nodePositions[edge.end];\n\n  if (startNodePosition && endNodePosition) {\n    const { startX, startY, endX, endY } = calculateEdgePosition(\n      startNodePosition,\n      endNodePosition\n    );\n\n    const strokeColor = edge.color || 'black';\n\n    svg\n      .append('line')\n      .attr('x1', startX || 0)\n      .attr('y1', startY || 0)\n      .attr('x2', endX || 0)\n      .attr('y2', endY || 0)\n      .attr('stroke', strokeColor)\n      .attr('stroke-width', '2');\n\n    if (edge.value) {\n      svg\n        .append('text')\n        .attr('x', (startX + endX) / 2)\n        .attr('y', (startY + endY) / 2)\n        .attr('fill', 'black')\n        .attr('font-size', '16')\n        .attr('dominant-baseline', 'middle')\n        .attr('text-anchor', 'middle')\n        .attr('class', 'edgeLabel')\n        .text(formatValue(edge.value));\n    }\n  }\n};\n\nconst calculateEdgePosition = (start: { x: number; y: number }, end: { x: number; y: number }) => {\n  const radius = 20; // Radius of the nodes\n  const deltaX = end.x - start.x;\n  const deltaY = end.y - start.y;\n  const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n\n  const offsetX = (deltaX * radius) / distance;\n  const offsetY = (deltaY * radius) / distance;\n\n  return {\n    startX: start.x + offsetX,\n    startY: start.y + offsetY,\n    endX: end.x - offsetX,\n    endY: end.y - offsetY,\n  };\n};\n", "import type { TreeDiagram } from './types.js';\nimport type { SVG } from '../../diagram-api/types.js';\nimport { getColor } from './getColor.js';\nimport { formatValue, shouldDisplayArrowLabel } from './valueFormatter.js';\n\nexport const drawTreeDiagram = (svg: SVG, treeDiagram: TreeDiagram, component_id: number) => {\n  const group = svg.append('g');\n  group.attr('class', 'component').attr('id', `component_${component_id}`);\n\n  // Define the marker for the arrowhead\n  group\n    .append('defs')\n    .append('marker')\n    .attr('id', 'arrowhead')\n    .attr('viewBox', '0 0 10 10')\n    .attr('refX', '5')\n    .attr('refY', '5')\n    .attr('markerWidth', '4')\n    .attr('markerHeight', '5')\n    .attr('orient', 'auto')\n    .append('path')\n    .attr('d', 'M 0 0 L 10 5 L 0 10 z')\n    .attr('fill', 'black');\n\n  const treeNodes = treeDiagram.elements || [];\n  const treeEdges = calculateTreeEdges(treeNodes);\n\n  // Calculate node positions in a tree layout\n  const nodePositions = calculateNodePositions(treeNodes);\n\n  // Draw tree edges first\n  if (treeEdges) {\n    treeEdges.forEach((edge) => {\n      drawEdge(group as unknown as SVG, edge, nodePositions);\n    });\n  }\n\n  // Draw tree nodes\n  if (treeNodes) {\n    let unit_id = 0;\n    treeNodes.forEach((node) => {\n      drawNode(group as unknown as SVG, node, nodePositions[node.nodeId], unit_id);\n      unit_id += 1;\n    });\n  }\n\n  if (treeDiagram.label) {\n    // Add the label at the bottom\n    const labelYPosition = treeNodes ? Math.ceil(treeNodes.length / 3) * 100 + 70 : 100;\n    const labelXPosition = 150; // Adjust based on your diagram size and layout\n\n    group\n      .append('text')\n      .attr('x', labelXPosition)\n      .attr('y', labelYPosition)\n      .attr('fill', 'black')\n      .attr('font-size', '16')\n      .attr('dominant-baseline', 'hanging')\n      .attr('text-anchor', 'middle')\n      .attr('class', 'treeDiagramLabel')\n      .text(treeDiagram.label);\n  }\n};\n\nconst calculateNodePositions = (nodes: any[]): { [key: string]: { x: number; y: number } } => {\n  const positions: { [key: string]: { x: number; y: number } } = {};\n  const levelHeight = 100;\n  const maxDepth = calculateMaxDepth(nodes);\n  const maxDistance = maxDepth > 2 ? 100 : 70; // Adjust this value based on the total number of layers\n  const currentY = 0;\n\n  const calculatePosition = (node: any, currentX: number, depth: number) => {\n    const adjustedSiblingDistance = maxDistance - depth * (maxDistance / maxDepth);\n    const x = currentX;\n    const y = currentY + depth * levelHeight;\n    positions[node.nodeId] = { x, y };\n\n    const leftChild = nodes.find((n) => n.nodeId === node.left);\n    const rightChild = nodes.find((n) => n.nodeId === node.right);\n    if (leftChild) {\n      calculatePosition(leftChild, x - adjustedSiblingDistance, depth + 1);\n    }\n    if (rightChild) {\n      calculatePosition(rightChild, x + adjustedSiblingDistance, depth + 1);\n    }\n  };\n\n  const rootNode = nodes.find((node) => !node.parentId);\n  if (rootNode) {\n    calculatePosition(rootNode, 150, 0); // Start from the center horizontally\n  }\n\n  return positions;\n};\n\nconst calculateMaxDepth = (nodes: any[]): number => {\n  const findDepth = (node: any, depth: number): number => {\n    const leftChild = nodes.find((n) => n.nodeId === node.left);\n    const rightChild = nodes.find((n) => n.nodeId === node.right);\n    const leftDepth = leftChild ? findDepth(leftChild, depth + 1) : depth;\n    const rightDepth = rightChild ? findDepth(rightChild, depth + 1) : depth;\n    return Math.max(leftDepth, rightDepth);\n  };\n\n  const rootNode = nodes.find((node) => !node.parentId);\n  if (rootNode) {\n    return findDepth(rootNode, 0);\n  }\n  return 0;\n};\n\nconst calculateTreeEdges = (\n  nodes: any[]\n): { start: string; end: string; value?: string; color?: string }[] => {\n  const edges: { start: string; end: string; value?: string; color?: string }[] = [];\n\n  nodes.forEach((node) => {\n    if (node.left) {\n      edges.push({ start: node.nodeId, end: node.left });\n    }\n    if (node.right) {\n      edges.push({ start: node.nodeId, end: node.right });\n    }\n  });\n\n  return edges;\n};\n\nconst drawNode = (svg: SVG, node: any, position: { x: number; y: number }, unit_id: number) => {\n  const nodeX = position.x;\n  const nodeY = position.y;\n\n  const fillColor = getColor(node.color);\n\n  const group = svg.append('g');\n  group.attr('class', 'unit').attr('id', `unit_${unit_id}`);\n\n  group\n    .append('circle')\n    .attr('cx', nodeX)\n    .attr('cy', nodeY)\n    .attr('r', 20)\n    .style('fill', fillColor)\n    .attr('stroke', 'black')\n    .attr('stroke-width', '1')\n    .attr('class', 'treeNode');\n\n  group\n    .append('text')\n    .attr('x', nodeX)\n    .attr('y', nodeY)\n    .attr('dy', '.35em')\n    .attr('fill', 'black')\n    .attr('font-size', '16')\n    .attr('dominant-baseline', 'middle')\n    .attr('text-anchor', 'middle')\n    .attr('class', 'nodeLabel')\n    .text(formatValue(node.value || node.nodeId));\n\n  // Draw the arrow on the right side of the node, pointing towards the node\n  if (node.arrow && shouldDisplayArrowLabel(node.arrowLabel)) {\n    const arrowXStart = nodeX + 45; // Move further right to avoid overlap\n    const arrowXEnd = nodeX + 25; // End near the node edge\n\n    group\n      .append('line')\n      .attr('x1', arrowXStart)\n      .attr('y1', nodeY)\n      .attr('x2', arrowXEnd)\n      .attr('y2', nodeY)\n      .attr('stroke', 'black')\n      .attr('stroke-width', '2')\n      .attr('marker-end', 'url(#arrowhead)');\n\n    // Draw the arrow label if it exists\n    group\n      .append('text')\n      .attr('x', arrowXStart + 5)\n      .attr('y', nodeY) // Place the label slightly above the arrow\n      .attr('fill', 'black')\n      .attr('font-size', '16')\n      .attr('dominant-baseline', 'middle')\n      .attr('text-anchor', 'start')\n      .attr('class', 'arrowLabel')\n      .text(formatValue(node.arrowLabel || ''));\n  }\n};\n\nconst drawEdge = (\n  svg: SVG,\n  edge: { start: string; end: string; value?: string; color?: string },\n  nodePositions: { [key: string]: { x: number; y: number } }\n) => {\n  const startNodePosition = nodePositions[edge.start];\n  const endNodePosition = nodePositions[edge.end];\n\n  if (startNodePosition && endNodePosition) {\n    const { startX, startY, endX, endY } = calculateEdgePosition(\n      startNodePosition,\n      endNodePosition\n    );\n\n    const strokeColor = edge.color || 'black';\n\n    svg\n      .append('line')\n      .attr('x1', startX)\n      .attr('y1', startY)\n      .attr('x2', endX)\n      .attr('y2', endY)\n      .attr('stroke', strokeColor)\n      .attr('stroke-width', '2');\n\n    if (edge.value) {\n      svg\n        .append('text')\n        .attr('x', (startX + endX) / 2)\n        .attr('y', (startY + endY) / 2)\n        .attr('fill', 'black')\n        .attr('font-size', '16')\n        .attr('dominant-baseline', 'middle')\n        .attr('text-anchor', 'middle')\n        .attr('class', 'edgeLabel')\n        .text(formatValue(edge.value));\n    }\n  }\n};\n\nconst calculateEdgePosition = (start: { x: number; y: number }, end: { x: number; y: number }) => {\n  const radius = 20; // Radius of the nodes\n  const deltaX = end.x - start.x;\n  const deltaY = end.y - start.y;\n  const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n\n  const offsetX = (deltaX * radius) / distance;\n  const offsetY = (deltaY * radius) / distance;\n\n  return {\n    startX: start.x + offsetX,\n    startY: start.y + offsetY,\n    endX: end.x - offsetX,\n    endY: end.y - offsetY,\n  };\n};\n", "import type { LinkedListDiagram, LinkedListElement } from './types.js';\nimport type { SVG } from '../../diagram-api/types.js';\nimport { getColor } from './getColor.js';\nimport { formatValue, shouldDisplayArrowLabel } from './valueFormatter.js';\n\nexport const drawLinkedListDiagram = (\n  svg: SVG,\n  linkedListDiagram: LinkedListDiagram,\n  component_id: number\n) => {\n  const group = svg.append('g');\n  group.attr('class', 'component').attr('id', `component_${component_id}`);\n\n  // Define the marker for the arrowhead_node\n  group\n    .append('defs')\n    .append('marker')\n    .attr('id', 'arrowhead_node')\n    .attr('viewBox', '0 0 10 10')\n    .attr('refX', '5')\n    .attr('refY', '5')\n    .attr('markerWidth', '5')\n    .attr('markerHeight', '6')\n    .attr('orient', 'auto')\n    .append('path')\n    .attr('d', 'M 0 0 L 10 5 L 0 10 z')\n    .attr('fill', 'black');\n\n  // Define the marker for the arrowhead\n  group\n    .append('defs')\n    .append('marker')\n    .attr('id', 'arrowhead')\n    .attr('viewBox', '0 0 10 10')\n    .attr('refX', '5')\n    .attr('refY', '5')\n    .attr('markerWidth', '3')\n    .attr('markerHeight', '5')\n    .attr('orient', 'auto')\n    .append('path')\n    .attr('d', 'M 0 0 L 10 5 L 0 10 z')\n    .attr('fill', 'black');\n\n  const linkedListNodes = linkedListDiagram.elements;\n\n  // Calculate node positions in a linear layout\n  const nodePositions = calculateNodePositions(linkedListNodes || []);\n  let unit_id = 0;\n  // Draw linked list nodes and arrows\n  if (linkedListNodes) {\n    linkedListNodes.forEach((node, index) => {\n      drawNode(\n        group as unknown as SVG,\n        node,\n        nodePositions[index],\n        index < linkedListNodes.length - 1,\n        unit_id\n      );\n      unit_id += 1;\n    });\n  }\n\n  if (linkedListDiagram.label) {\n    // Add the label at the bottom\n    const labelYPosition = 100;\n    const labelXPosition = 150; // Adjust based on your diagram size and layout\n\n    group\n      .append('text')\n      .attr('x', labelXPosition)\n      .attr('y', labelYPosition)\n      .attr('fill', 'black')\n      .attr('font-size', '18')\n      .attr('dominant-baseline', 'hanging')\n      .attr('text-anchor', 'middle')\n      .attr('class', 'linkedListDiagramLabel')\n      .text(linkedListDiagram.label);\n  }\n};\n\nconst calculateNodePositions = (nodes: LinkedListElement[]): { x: number; y: number }[] => {\n  const positions: { x: number; y: number }[] = [];\n  const startX = 50; // Starting X position\n  const startY = 50; // Starting Y position\n  const nodeSpacing = 120; // Increased spacing between nodes\n\n  nodes.forEach((_, index) => {\n    positions.push({\n      x: startX + index * nodeSpacing,\n      y: startY,\n    });\n  });\n\n  return positions;\n};\n\nconst drawNode = (\n  svg: SVG,\n  node: LinkedListElement,\n  position: { x: number; y: number },\n  hasNext: boolean,\n  unit_id: number\n) => {\n  const nodeX = position.x;\n  const nodeY = position.y;\n\n  const fillColor = getColor(node.color);\n  const group = svg.append('g');\n  group.attr('class', 'unit').attr('id', `unit_${unit_id}`);\n\n  // Draw the rectangle for the node\n  group\n    .append('rect')\n    .attr('x', nodeX)\n    .attr('y', nodeY)\n    .attr('width', 60)\n    .attr('height', 30)\n    .style('fill', fillColor)\n    .attr('stroke', 'black')\n    .attr('stroke-width', '1')\n    .attr('class', 'linkedListNode');\n\n  // Draw the text for the node value\n  group\n    .append('text')\n    .attr('x', nodeX + 30)\n    .attr('y', nodeY + 15)\n    .attr('dy', '.35em')\n    .attr('fill', 'black')\n    .attr('font-size', '18')\n    .attr('dominant-baseline', 'middle')\n    .attr('text-anchor', 'middle')\n    .attr('class', 'nodeLabel')\n    .text(formatValue(node.value));\n\n  // Draw the smaller arrow above the node if it exists and the arrowLabel is not \"null\"\n  if (shouldDisplayArrowLabel(node.arrowLabel)) {\n    const arrowYStart = nodeY - 30; // Start of the arrow, closer to the node\n    const arrowYEnd = nodeY - 10; // End of the arrow, just above the node\n\n    group\n      .append('line')\n      .attr('x1', nodeX + 30)\n      .attr('y1', arrowYStart)\n      .attr('x2', nodeX + 30)\n      .attr('y2', arrowYEnd)\n      .attr('stroke', 'black')\n      .attr('stroke-width', '2')\n      .attr('marker-end', 'url(#arrowhead)');\n\n    // Draw the arrow label\n    group\n      .append('text')\n      .attr('x', nodeX + 30)\n      .attr('y', arrowYStart - 10) // Place the label above the arrow\n      .attr('fill', 'black')\n      .attr('font-size', '16')\n      .attr('dominant-baseline', 'middle')\n      .attr('text-anchor', 'middle')\n      .attr('class', 'arrowLabel')\n      .text(formatValue(node.arrowLabel || ''));\n  }\n\n  // Draw the longer connecting line to the next node if there is one\n  if (hasNext) {\n    group\n      .append('line')\n      .attr('x1', nodeX + 60)\n      .attr('y1', nodeY + 15)\n      .attr('x2', nodeX + 60 + 55) // Increased length of the connecting line\n      .attr('y2', nodeY + 15)\n      .attr('stroke', 'black')\n      .attr('stroke-width', '2')\n      .attr('marker-end', 'url(#arrowhead_node)');\n  }\n};\n", "import type { TextDiagram, TextElement } from './types.js';\nimport type { SVG } from '../../diagram-api/types.js';\nimport { formatValue } from './valueFormatter.js';\n\nexport const drawTextDiagram = (svg: SVG, textDiagram: TextDiagram, component_id: number) => {\n  const group = svg.append('g');\n  group.attr('class', 'component').attr('id', `component_${component_id}`);\n\n  let currentY = 0; // Initialize the current Y position\n\n  // Draw each text element\n  let unit_id = 0;\n\n  textDiagram.elements.forEach((element) => {\n    currentY = drawElement(group as unknown as SVG, element, currentY, unit_id, textDiagram);\n    unit_id += 1;\n  });\n\n  if (textDiagram.label) {\n    const labelYPosition = currentY + (textDiagram.lineSpacing || 20); // Use diagram's line spacing\n    const labelAlign = textDiagram.align || 'left';\n    let labelXPosition = 50;\n    let textAnchor = 'start';\n\n    // Calculate label position based on alignment\n    switch (labelAlign) {\n      case 'center':\n        textAnchor = 'middle';\n        labelXPosition = (textDiagram.width || 200) / 2;\n        break;\n      case 'right':\n        textAnchor = 'end';\n        labelXPosition = (textDiagram.width || 200) - 50;\n        break;\n      default:\n        textAnchor = 'start';\n        labelXPosition = 50;\n    }\n\n    group\n      .append('text')\n      .attr('x', labelXPosition)\n      .attr('y', labelYPosition)\n      .attr('fill', textDiagram.color || 'black')\n      .attr('font-size', textDiagram.fontSize || 16)\n      .attr('font-weight', textDiagram.fontWeight || 'normal')\n      .attr('font-family', textDiagram.fontFamily || 'sans-serif')\n      .attr('dominant-baseline', 'hanging')\n      .attr('text-anchor', textAnchor)\n      .attr('class', 'textDiagramLabel')\n      .text(textDiagram.label);\n  }\n};\n\nconst drawElement = (\n  svg: SVG,\n  element: string | TextElement,\n  startY: number,\n  unit_id: number,\n  diagramDefaults?: Partial<TextDiagram>\n) => {\n  const group = svg.append('g').attr('class', 'unit').attr('id', `unit_${unit_id}`);\n\n  // Parse element properties\n  let elementValue: string;\n  let elementProps: Partial<TextElement> = {};\n\n  if (typeof element === 'string') {\n    elementValue = element;\n  } else {\n    elementValue = element.value;\n    elementProps = element;\n  }\n\n  // Default positioning\n  const defaultX = 50;\n\n  // Use element properties with fallback to diagram defaults\n  const fontSize = elementProps.fontSize || diagramDefaults?.fontSize || 20;\n  const color = elementProps.color || diagramDefaults?.color || 'black';\n  const fontWeight = elementProps.fontWeight || diagramDefaults?.fontWeight || 'normal';\n  const fontFamily = elementProps.fontFamily || diagramDefaults?.fontFamily || 'sans-serif';\n  const align = elementProps.align || diagramDefaults?.align || 'left';\n  const lineSpacing = diagramDefaults?.lineSpacing || 20;\n\n  // Calculate text anchor based on alignment\n  let textAnchor: string;\n  let elementX = defaultX;\n\n  switch (align) {\n    case 'center':\n      textAnchor = 'middle';\n      elementX = (diagramDefaults?.width || 200) / 2;\n      break;\n    case 'right':\n      textAnchor = 'end';\n      elementX = (diagramDefaults?.width || 200) - 50;\n      break;\n    default:\n      textAnchor = 'start';\n      elementX = defaultX;\n  }\n\n  const lines = elementValue.split('\\n');\n\n  lines.forEach((line, lineIndex) => {\n    const lineY = startY + lineIndex * lineSpacing;\n    group\n      .append('text')\n      .attr('x', elementX)\n      .attr('y', lineY)\n      .attr('fill', color)\n      .attr('font-size', fontSize)\n      .attr('font-weight', fontWeight)\n      .attr('font-family', fontFamily)\n      .attr('dominant-baseline', 'hanging')\n      .attr('text-anchor', textAnchor)\n      .attr('class', 'textElement')\n      .text(formatValue(line));\n  });\n\n  // Return the updated Y position for the next element\n  return startY + lines.length * lineSpacing;\n};\n", "import * as d3 from 'd3';\nimport type { Diagram } from '../../Diagram.js';\nimport type { DiagramRenderer, DrawDefinition, SVG } from '../../diagram-api/types.js';\nimport { selectSvgElement } from '../../rendering-util/selectSvgElement.js';\nimport { configureSvgSize } from '../../setupGraphViewbox.js';\nimport type {\n  VisualDB,\n  VisualPage,\n  ArrayDiagram,\n  MatrixDiagram,\n  StackDiagram,\n  GraphDiagram,\n  TreeDiagram,\n  LinkedListDiagram,\n  TextDiagram,\n} from './types.js';\nimport { drawArrayDiagram } from './drawArrayDiagram.js';\nimport { drawMatrixDiagram } from './drawMatrixDiagram.js';\nimport { drawStackDiagram } from './drawStackDiagram.js';\nimport { drawGraphDiagram } from './drawGraphDiagram.js';\nimport { drawTreeDiagram } from './drawTreeDiagram.js';\nimport { drawLinkedListDiagram } from './drawLinkedListDiagram.js';\nimport { drawTextDiagram } from './drawTextDiagram.js';\n\ninterface ProcessedGroup {\n  type: string;\n  position?: { column: number; row: number };\n  mainItem: any;\n  textItems: Array<{ item: any; placement: 'above' | 'below' | 'left' | 'right' }>;\n}\n\nconst processItemsWithRelativePositioning = (subDiagrams: any[]): ProcessedGroup[] => {\n  const groups: ProcessedGroup[] = [];\n  const processedIndices = new Set<number>();\n\n  subDiagrams.forEach((subDiagram, index) => {\n    if (processedIndices.has(index)) {\n      return;\n    }\n\n    // Check if this is a text item with position: previous\n    if (\n      subDiagram.type === 'text' &&\n      subDiagram.position &&\n      typeof subDiagram.position === 'object' &&\n      'type' in subDiagram.position &&\n      subDiagram.position.type === 'previous'\n    ) {\n      // This text item should be associated with the previous non-text item\n      // Find the most recent group that's not a standalone text\n      const targetGroup = groups[groups.length - 1];\n      if (targetGroup) {\n        targetGroup.textItems.push({\n          item: { ...subDiagram, index }, // Ensure the index is preserved\n          placement: subDiagram.position.placement || subDiagram.placement || 'below',\n        });\n        processedIndices.add(index);\n      }\n      return;\n    }\n\n    // Regular item (including text with absolute position or no position)\n    const group: ProcessedGroup = {\n      type: subDiagram.type,\n      position:\n        subDiagram.position && 'column' in subDiagram.position ? subDiagram.position : undefined,\n      mainItem: { ...subDiagram, index }, // Ensure the index is preserved here too\n      textItems: [],\n    };\n\n    groups.push(group);\n    processedIndices.add(index);\n  });\n\n  return groups;\n};\n\nconst draw: DrawDefinition = (_text, id, _version, diagram: Diagram) => {\n  const db = diagram.db as VisualDB;\n  const config = db.getConfig();\n  const pages = db.getPages();\n  const title = db.getDiagramTitle();\n  const customSize = db.getSize && db.getSize();\n\n  // Use custom size if specified, otherwise default\n  const svgWidth = customSize?.width || 1000;\n  const svgHeight = customSize?.height || 800;\n\n  const svg: SVG = selectSvgElement(id);\n\n  const currentPage = 0;\n  const playInterval: number | null = null;\n\n  const renderPage = (pageIndex: number) => {\n    svg.selectAll('g.page').attr('display', 'none');\n    svg.select(`#page${pageIndex}`).attr('display', 'inline');\n\n    // Update button states\n    svg.select('#prevButton').attr('fill', pageIndex > 0 ? '#007bff' : '#c0c0c0');\n    svg.select('#nextButton').attr('fill', pageIndex < pages.length - 1 ? '#007bff' : '#c0c0c0');\n\n    // Update current page display\n    svg.select('#pageIndicator').text(`${pageIndex + 1} / ${pages.length}`);\n  };\n\n  // const addNavigationButtons = (svg: SVG, totalPages: number) => {\n  //   const buttonGroup = svg.append('g').attr('class', 'navigation-buttons');\n\n  //   const buttonWidth = 40;\n  //   const buttonHeight = 20;\n  //   const buttonSpacing = 10;\n\n  //   const buttonsX = svgWidth / 2 - (buttonWidth * 1.5 + buttonSpacing);\n  //   const buttonsY = svgHeight - 60; // Adjusted y position\n\n  //   // Prev button\n  //   const prevButtonGroup = buttonGroup\n  //     .append('g')\n  //     .attr('id', 'prevButtonGroup')\n  //     .attr('cursor', 'pointer');\n\n  //   prevButtonGroup\n  //     .append('rect')\n  //     .attr('id', 'prevButton')\n  //     .attr('x', buttonsX)\n  //     .attr('y', buttonsY)\n  //     .attr('width', buttonWidth)\n  //     .attr('height', buttonHeight)\n  //     .attr('fill', '#c0c0c0'); // Initially disabled\n\n  //   prevButtonGroup\n  //     .append('text')\n  //     .text('<')\n  //     .attr('x', buttonsX + buttonWidth / 2)\n  //     .attr('y', buttonsY + buttonHeight / 2)\n  //     .attr('fill', 'white')\n  //     .attr('text-anchor', 'middle')\n  //     .attr('alignment-baseline', 'middle');\n\n  //   // Play button\n  //   const playButtonGroup = buttonGroup\n  //     .append('g')\n  //     .attr('id', 'playButtonGroup')\n  //     .attr('cursor', 'pointer');\n\n  //   playButtonGroup\n  //     .append('rect')\n  //     .attr('id', 'playButton')\n  //     .attr('x', buttonsX + buttonWidth + buttonSpacing)\n  //     .attr('y', buttonsY)\n  //     .attr('width', buttonWidth)\n  //     .attr('height', buttonHeight)\n  //     .attr('fill', '#007bff'); // Initially enabled\n\n  //   playButtonGroup\n  //     .append('text')\n  //     .text('\u25B6')\n  //     .attr('x', buttonsX + buttonWidth + buttonSpacing + buttonWidth / 2)\n  //     .attr('y', buttonsY + buttonHeight / 2)\n  //     .attr('fill', 'white')\n  //     .attr('text-anchor', 'middle')\n  //     .attr('alignment-baseline', 'middle');\n\n  //   // Next button\n  //   const nextButtonGroup = buttonGroup\n  //     .append('g')\n  //     .attr('id', 'nextButtonGroup')\n  //     .attr('cursor', 'pointer');\n\n  //   nextButtonGroup\n  //     .append('rect')\n  //     .attr('id', 'nextButton')\n  //     .attr('x', buttonsX + 2 * (buttonWidth + buttonSpacing))\n  //     .attr('y', buttonsY)\n  //     .attr('width', buttonWidth)\n  //     .attr('height', buttonHeight)\n  //     .attr('fill', '#007bff'); // Initially enabled\n\n  //   nextButtonGroup\n  //     .append('text')\n  //     .text('>')\n  //     .attr('x', buttonsX + 2 * (buttonWidth + buttonSpacing) + buttonWidth / 2)\n  //     .attr('y', buttonsY + buttonHeight / 2)\n  //     .attr('fill', 'white')\n  //     .attr('text-anchor', 'middle')\n  //     .attr('alignment-baseline', 'middle');\n\n  //   // Page indicator\n  //   buttonGroup\n  //     .append('text')\n  //     .attr('id', 'pageIndicator')\n  //     .attr('x', svgWidth - 50)\n  //     .attr('y', svgHeight - 50)\n  //     .attr('fill', 'black')\n  //     .attr('text-anchor', 'middle')\n  //     .attr('alignment-baseline', 'middle')\n  //     .text(`1 / ${totalPages}`);\n\n  //   prevButtonGroup.node()?.addEventListener('click', () => {\n  //     if (currentPage > 0) {\n  //       currentPage -= 1;\n  //       renderPage(currentPage);\n  //     }\n  //   });\n\n  //   nextButtonGroup.node()?.addEventListener('click', () => {\n  //     if (currentPage < totalPages - 1) {\n  //       currentPage += 1;\n  //       renderPage(currentPage);\n  //     }\n  //   });\n\n  //   playButtonGroup.node()?.addEventListener('click', () => {\n  //     if (playInterval) {\n  //       clearInterval(playInterval);\n  //       playInterval = null;\n  //       d3.select('#playButton text').text('\u25B6');\n  //       d3.select('#playButton').attr('fill', '#007bff');\n  //     } else {\n  //       playInterval = 1000;\n  //       d3.select('#playButton text').text('\u275A\u275A');\n  //       d3.select('#playButton').attr('fill', '#c0c0c0');\n  //     }\n  //   });\n  // };\n\n  const drawPage = (svg: SVG, page: VisualPage, pageIndex: number) => {\n    const pageGroup = svg\n      .append('g')\n      .attr('id', `page${pageIndex}`)\n      .attr('class', 'page')\n      .attr('display', pageIndex === 0 ? 'inline' : 'none');\n\n    if (title) {\n      pageGroup\n        .append('text')\n        .text(title)\n        .attr('x', svgWidth / 2)\n        .attr('y', 25)\n        .attr('dominant-baseline', 'middle')\n        .attr('text-anchor', 'middle')\n        .attr('class', 'pageTitle');\n    }\n\n    // Handle layout and positioning\n    const layout = page.layout || { columns: 1, rows: 1 };\n    const titleOffset = title ? 50 : 20;\n    const availableWidth = svgWidth - 40; // 20px margin on each side\n    const availableHeight = svgHeight - titleOffset - 20; // Title + bottom margin\n\n    // Process positioning and group text elements with their reference items\n    const processedGroups = processItemsWithRelativePositioning(page.subDiagrams);\n\n    // Pre-calculate: Count items with and without positions\n    const itemsWithPositions: Array<{ item: any; position: { column: number; row: number } }> = [];\n    const itemsWithoutPositions: Array<any> = [];\n\n    processedGroups.forEach((group, groupIndex) => {\n      if (group.position) {\n        // Convert 1-based to 0-based indexing and validate\n        const col = group.position.column - 1;\n        const row = group.position.row - 1;\n\n        if (row >= 0 && row < layout.rows && col >= 0 && col < layout.columns) {\n          itemsWithPositions.push({\n            item: group, // Don't override the existing index\n            position: { column: col, row },\n          });\n        } else {\n          // Invalid position, treat as item without position\n          itemsWithoutPositions.push(group); // Don't override the existing index\n        }\n      } else {\n        itemsWithoutPositions.push(group); // Don't override the existing index\n      }\n    });\n\n    // Pre-calculate grid expansion: Check if we need more space\n    const totalCells = layout.columns * layout.rows;\n    const occupiedCells = itemsWithPositions.length;\n    const availableCells = totalCells - occupiedCells;\n    const itemsNeedingSpace = itemsWithoutPositions.length;\n\n    // Smart grid expansion: maintain balanced proportions\n    if (itemsNeedingSpace > availableCells) {\n      const totalItemsNeeded = occupiedCells + itemsNeedingSpace;\n\n      // Start with current layout and expand intelligently\n      let newColumns = layout.columns;\n      let newRows = layout.rows;\n\n      // Calculate the current aspect ratio to maintain reasonable proportions\n      const currentAspectRatio = newColumns / newRows;\n      const maxAspectRatio = 3.0; // Don't let it get too wide or too tall\n\n      // If current layout is too small, expand both dimensions proportionally\n      while (newColumns * newRows < totalItemsNeeded) {\n        const currentAspect = newColumns / newRows;\n\n        // Prefer expanding the shorter dimension to keep layout balanced\n        // But also consider aspect ratio to prevent extreme layouts\n        if (currentAspect > maxAspectRatio) {\n          // Too wide, add rows\n          newRows++;\n        } else if (currentAspect < 1 / maxAspectRatio) {\n          // Too tall, add columns\n          newColumns++;\n        } else {\n          // Balanced layout, expand the shorter dimension\n          if (newColumns <= newRows) {\n            newColumns++;\n          } else {\n            newRows++;\n          }\n        }\n      }\n\n      // Update layout with new dimensions\n      layout.columns = newColumns;\n      layout.rows = newRows;\n    }\n\n    const cellWidth = availableWidth / layout.columns;\n    const cellHeight = availableHeight / layout.rows;\n\n    // Create grid positions mapping\n    const gridPositions: Array<Array<{ x: number; y: number; occupied: boolean }>> = [];\n    for (let row = 0; row < layout.rows; row++) {\n      gridPositions[row] = [];\n      for (let col = 0; col < layout.columns; col++) {\n        gridPositions[row][col] = {\n          x: 20 + col * cellWidth,\n          y: titleOffset + row * cellHeight,\n          occupied: false,\n        };\n      }\n    }\n\n    // Mark positions as occupied for explicitly positioned items\n    itemsWithPositions.forEach(({ position }) => {\n      gridPositions[position.row][position.column].occupied = true;\n    });\n\n    // Place items with explicit positions\n    itemsWithPositions.forEach(({ item, position }) => {\n      const gridPos = gridPositions[position.row][position.column];\n      drawGroupAtPosition(pageGroup, item, gridPos.x, gridPos.y, cellWidth, cellHeight, config);\n    });\n\n    // Place remaining items in available positions\n    let currentRow = 0;\n    let currentCol = 0;\n\n    itemsWithoutPositions.forEach((item) => {\n      // Find next available position\n      while (currentRow < layout.rows && gridPositions[currentRow][currentCol].occupied) {\n        currentCol++;\n        if (currentCol >= layout.columns) {\n          currentCol = 0;\n          currentRow++;\n        }\n      }\n\n      const gridPos = gridPositions[currentRow][currentCol];\n      drawGroupAtPosition(pageGroup, item, gridPos.x, gridPos.y, cellWidth, cellHeight, config);\n      gridPositions[currentRow][currentCol].occupied = true;\n\n      // Move to next position\n      currentCol++;\n      if (currentCol >= layout.columns) {\n        currentCol = 0;\n        currentRow++;\n      }\n    });\n  };\n\n  const drawSingleDiagram = (group: any, subDiagram: any, config: any) => {\n    switch (subDiagram.type) {\n      case 'array': {\n        drawArrayDiagram(\n          group as unknown as SVG,\n          subDiagram as ArrayDiagram,\n          config,\n          subDiagram.index\n        );\n        break;\n      }\n      case 'matrix': {\n        drawMatrixDiagram(\n          group as unknown as SVG,\n          subDiagram as MatrixDiagram,\n          config,\n          subDiagram.index\n        );\n        break;\n      }\n      case 'stack': {\n        drawStackDiagram(group as unknown as SVG, subDiagram as StackDiagram, subDiagram.index);\n        break;\n      }\n      case 'graph': {\n        drawGraphDiagram(group as unknown as SVG, subDiagram as GraphDiagram, subDiagram.index);\n        break;\n      }\n      case 'tree': {\n        drawTreeDiagram(group as unknown as SVG, subDiagram as TreeDiagram, subDiagram.index);\n        break;\n      }\n      case 'linkedList': {\n        drawLinkedListDiagram(\n          group as unknown as SVG,\n          subDiagram as LinkedListDiagram,\n          subDiagram.index\n        );\n        break;\n      }\n      case 'text': {\n        drawTextDiagram(group as unknown as SVG, subDiagram as TextDiagram, subDiagram.index);\n        break;\n      }\n      default:\n        throw new Error(`Unknown diagram type: ${subDiagram.type}`);\n    }\n  };\n\n  const drawGroupAtPosition = (\n    parentGroup: any,\n    group: ProcessedGroup,\n    x: number,\n    y: number,\n    maxWidth: number,\n    maxHeight: number,\n    config: any\n  ) => {\n    // If this is a simple group with just a main item and no text items, use the existing function\n    if (group.textItems.length === 0) {\n      drawDiagramAtPosition(parentGroup, group.mainItem, x, y, maxWidth, maxHeight, config);\n      return;\n    }\n\n    // Create a container group for the entire combined diagram\n    const containerGroup = parentGroup\n      .append('g')\n      .attr('class', `container-${group.type}`)\n      .attr('id', `container-${group.mainItem.index}`);\n\n    // Step 1: Draw main diagram to measure its size\n    const tempMainGroup = containerGroup\n      .append('g')\n      .attr('class', 'temp-main')\n      .style('visibility', 'hidden');\n\n    drawSingleDiagram(tempMainGroup, group.mainItem, config);\n    const mainBBox = (tempMainGroup.node() as SVGGElement).getBBox();\n    tempMainGroup.remove();\n\n    // Step 2: Draw text items to measure their sizes\n    const textMeasurements: Array<{\n      bbox: DOMRect;\n      placement: string;\n      item: any;\n    }> = [];\n\n    group.textItems.forEach(({ item, placement }) => {\n      const tempTextGroup = containerGroup\n        .append('g')\n        .attr('class', 'temp-text')\n        .style('visibility', 'hidden');\n\n      drawSingleDiagram(tempTextGroup, item, config);\n      const textBBox = (tempTextGroup.node() as SVGGElement).getBBox();\n      tempTextGroup.remove();\n\n      textMeasurements.push({\n        bbox: textBBox,\n        placement,\n        item,\n      });\n    });\n\n    // Step 3: Calculate layout based on text placements\n    let totalWidth = mainBBox.width;\n    let totalHeight = mainBBox.height;\n\n    // Calculate additional space needed for text items\n    let leftSpace = 0,\n      rightSpace = 0,\n      topSpace = 0,\n      bottomSpace = 0;\n\n    textMeasurements.forEach(({ bbox, placement }) => {\n      const padding = 10; // Space between main diagram and text\n      switch (placement) {\n        case 'left':\n          leftSpace = Math.max(leftSpace, bbox.width + padding);\n          break;\n        case 'right':\n          rightSpace = Math.max(rightSpace, bbox.width + padding);\n          break;\n        case 'above':\n          topSpace = Math.max(topSpace, bbox.height + padding);\n          break;\n        case 'below':\n          bottomSpace = Math.max(bottomSpace, bbox.height + padding);\n          break;\n      }\n    });\n\n    totalWidth += leftSpace + rightSpace;\n    totalHeight += topSpace + bottomSpace;\n\n    // Step 4: Calculate scaling to fit in the available space\n    const padding = 20;\n    const availableWidth = maxWidth - padding;\n    const availableHeight = maxHeight - padding;\n\n    const scaleX = availableWidth / totalWidth;\n    const scaleY = availableHeight / totalHeight;\n    const scale = Math.min(scaleX, scaleY, 1);\n\n    // Step 5: Calculate positions for centering the entire group\n    const cellCenterX = x + maxWidth / 2;\n    const cellCenterY = y + maxHeight / 2;\n\n    const groupCenterX = (totalWidth * scale) / 2;\n    const groupCenterY = (totalHeight * scale) / 2;\n\n    const groupX = cellCenterX - groupCenterX;\n    const groupY = cellCenterY - groupCenterY;\n\n    // Step 6: Apply transform to container\n    containerGroup.attr('transform', `translate(${groupX}, ${groupY}) scale(${scale})`);\n\n    // Step 7: Position and draw the main diagram\n    const mainX = leftSpace - mainBBox.x;\n    const mainY = topSpace - mainBBox.y;\n\n    const mainGroup = containerGroup\n      .append('g')\n      .attr('class', `main-${group.type}`)\n      .attr('transform', `translate(${mainX}, ${mainY})`);\n\n    drawSingleDiagram(mainGroup, group.mainItem, config);\n\n    // Step 8: Position and draw text items\n    textMeasurements.forEach(({ bbox, placement, item }) => {\n      const textGroup = containerGroup.append('g').attr('class', 'text-item');\n\n      let textX = 0,\n        textY = 0;\n\n      // Calculate position relative to the main diagram's actual position\n      const mainActualX = leftSpace;\n      const mainActualY = topSpace;\n\n      switch (placement) {\n        case 'left':\n          textX = mainActualX - bbox.width - 10;\n          textY = mainActualY + mainBBox.height / 2 - bbox.height / 2;\n          break;\n        case 'right':\n          textX = mainActualX + mainBBox.width + 10;\n          textY = mainActualY + mainBBox.height / 2 - bbox.height / 2;\n          break;\n        case 'above':\n          textX = mainActualX + mainBBox.width / 2 - bbox.width / 2;\n          textY = mainActualY - bbox.height - 10;\n          break;\n        case 'below':\n          textX = mainActualX + mainBBox.width / 2 - bbox.width / 2;\n          textY = mainActualY + mainBBox.height + 10;\n          break;\n      }\n\n      // Account for the text's own bbox offset\n      textX -= bbox.x;\n      textY -= bbox.y;\n\n      textGroup.attr('transform', `translate(${textX}, ${textY})`);\n      drawSingleDiagram(textGroup, item, config);\n    });\n  };\n\n  const drawDiagramAtPosition = (\n    parentGroup: any,\n    subDiagram: any,\n    x: number,\n    y: number,\n    maxWidth: number,\n    maxHeight: number,\n    config: any\n  ) => {\n    // Step 1: Create a temporary group to draw and measure the diagram\n    const tempGroup = parentGroup\n      .append('g')\n      .attr('class', 'temp-measure')\n      .style('visibility', 'hidden'); // Hidden while we measure\n\n    // Step 2: Draw the diagram at origin to measure its natural size\n    drawSingleDiagram(tempGroup, subDiagram, config);\n\n    // Step 3: Get the actual bounding box of the drawn diagram\n    const bbox = (tempGroup.node() as SVGGElement).getBBox();\n    const actualWidth = bbox.width;\n    const actualHeight = bbox.height;\n    const actualLeft = bbox.x;\n    const actualTop = bbox.y;\n\n    // Step 4: Calculate available space with padding\n    const padding = 20;\n    const availableWidth = maxWidth - padding;\n    const availableHeight = maxHeight - padding;\n\n    // Step 5: Calculate scaling to fit the diagram in the available space\n    const scaleX = availableWidth / actualWidth;\n    const scaleY = availableHeight / actualHeight;\n    const scale = Math.min(scaleX, scaleY, 1); // Don't scale up\n\n    // Step 6: Calculate positioning to center the diagram in the cell\n    const cellCenterX = x + maxWidth / 2;\n    const cellCenterY = y + maxHeight / 2;\n\n    // Calculate where to place the diagram so its center aligns with cell center\n    const diagramCenterX = actualLeft + actualWidth / 2;\n    const diagramCenterY = actualTop + actualHeight / 2;\n\n    const translateX = cellCenterX - diagramCenterX * scale;\n    const translateY = cellCenterY - diagramCenterY * scale;\n\n    // Step 7: Remove the temporary measurement group\n    tempGroup.remove();\n\n    // Step 8: Create the final viewport group with proper positioning\n    const viewportGroup = parentGroup\n      .append('g')\n      .attr('class', `viewport-${subDiagram.type}`)\n      .attr('id', `viewport-${subDiagram.index}`);\n\n    // Apply the calculated transform\n    if (scale < 1) {\n      viewportGroup.attr('transform', `translate(${translateX}, ${translateY}) scale(${scale})`);\n    } else {\n      viewportGroup.attr('transform', `translate(${translateX}, ${translateY})`);\n    }\n\n    // Step 9: Draw the diagram again in the final position\n    drawSingleDiagram(viewportGroup, subDiagram, config);\n  };\n\n  svg.attr('viewBox', `0 0 ${svgWidth} ${svgHeight}`);\n  configureSvgSize(svg, svgHeight, svgWidth, config.useMaxWidth);\n\n  pages.forEach((page, index) => {\n    drawPage(svg, page, index);\n  });\n\n  // // addNavigationButtons(svg, pages.length);\n\n  // renderPage(currentPage);\n\n  // // Inject page-switching logic directly into the SVG as JavaScript\n  // const switchPageScript = `\n  //   (function() {\n  //     const svg = document.getElementById('${id}');\n  //     let currentPage = 0;\n  //     const totalPages = ${pages.length};\n  //     let playInterval = null;\n\n  //     function renderPage(pageIndex) {\n  //       const pages = svg.querySelectorAll('g.page');\n  //       pages.forEach(page => {\n  //         page.style.display = 'none';\n  //       });\n  //       svg.querySelector('#page' + pageIndex).style.display = 'inline';\n\n  //       const prevButton = svg.querySelector('#prevButton');\n  //       const nextButton = svg.querySelector('#nextButton');\n\n  //       if (prevButton) prevButton.setAttribute('fill', pageIndex > 0 ? '#007bff' : '#c0c0c0');\n  //       if (nextButton) nextButton.setAttribute('fill', pageIndex < totalPages - 1 ? '#007bff' : '#c0c0c0');\n\n  //       // Update current page display\n  //       svg.querySelector('#pageIndicator').textContent = (pageIndex + 1) + ' / ' + totalPages;\n  //     }\n\n  //     svg.querySelector('#prevButtonGroup').addEventListener('click', function() {\n  //       if (currentPage > 0) {\n  //         currentPage -= 1;\n  //         renderPage(currentPage);\n  //       }\n  //     });\n\n  //     svg.querySelector('#nextButtonGroup').addEventListener('click', function() {\n  //       if (currentPage < totalPages - 1) {\n  //         currentPage += 1;\n  //         renderPage(currentPage);\n  //       }\n  //     });\n\n  //     svg.querySelector('#playButtonGroup').addEventListener('click', function() {\n  //       if (playInterval) {\n  //         clearInterval(playInterval);\n  //         playInterval = null;\n  //         svg.querySelector('#playButton text').textContent = '\u25B6';\n  //         svg.querySelector('#playButton').setAttribute('fill', '#007bff');\n  //       } else {\n  //         playInterval = setInterval(() => {\n  //           if (currentPage < totalPages - 1) {\n  //             currentPage += 1;\n  //           } else {\n  //             currentPage = 0;\n  //           }\n  //           renderPage(currentPage);\n  //         }, 1000);\n  //         svg.querySelector('#playButton text').textContent = '\u275A\u275A';\n  //         svg.querySelector('#playButton').setAttribute('fill', '#c0c0c0');\n  //       }\n  //     });\n\n  //     renderPage(currentPage);\n  //   })();\n  // `;\n\n  // svg.append('script').attr('type', 'text/javascript').text(switchPageScript);\n};\n\nexport const renderer: DiagramRenderer = { draw };\n", "import { log } from '../../logger.js';\n\nexport const styles = (options: any = {}) => {\n  log.debug({ options });\n  return `\n    .element {\n      font-size: ${options.array?.elementFontSize ?? '10px'};\n      fill: ${options.array?.valueColor ?? 'black'};\n    }\n    .element.index {\n      fill: ${options.array?.indexColor ?? 'black'};\n    }\n    .element {\n      stroke: ${options.array?.elementStrokeColor ?? 'black'};\n      stroke-width: ${options.array?.elementStrokeWidth ?? '1'};\n      fill: ${options.array?.elementFillColor ?? '#efefef'};\n    }\n  `;\n};\n\nexport default styles;\n", "import type { DiagramDefinition } from '../../diagram-api/types.js';\nimport { db } from './db.js';\nimport { parser } from './parser.js';\nimport { renderer } from './renderer.js';\nimport { styles } from './styles.js';\n\nexport const diagram: DiagramDefinition = {\n  parser,\n  db,\n  renderer,\n  styles,\n};\n"],
  "mappings": "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",
  "names": ["getConfig", "clear", "drawElement", "drawElement", "calculateNodePositions", "drawEdge", "drawNode", "calculateEdgePosition", "calculateNodePositions", "drawNode", "drawElement", "diagram", "db", "svg", "config", "padding"]
}
